pragma solidity >=0.5.0 <0.9.0;

/**
 * @title DiscoveryMergeNFT
 * @dev NFTs for merging course content on gitbook
*/

import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import './RandomNumberConsumer.sol';
import './Verify.sol';


contract ProjectNFT is ERC721URIStorage, Ownable{
    using Counters for Counters.Counter;
    
    Counters.Counter private _tokenIds;
    address marketplace;
    RandomNumberConsumer randomNumberContract;

    mapping (address => bool) approvers;
    mapping (string => uint[]) courseIndices;
    //mapping (string => bool) public checkNFTURI;
    mapping (string => mapping (string => bool)) public didQuestCheck;
    Verify private signVerifyContract; //contract to verify the signatures 

    event NFTCommitMinted(address indexed _to, string indexed _tokenURI, string indexed _questId);
    event ReceiveCalled(address _caller, uint _value);


    constructor(address payable _verifyAddress, address _marketplace, address _vrfAddress) ERC721("dCompass", "DCOMP") public{
        signVerifyContract = Verify(_verifyAddress);
        approvers[msg.sender] = true;
        marketplace = _marketplace;
        randomNumberContract = RandomNumberConsumer(_vrfAddress);
    } 

    modifier onlyApprover(){
        require(approvers[msg.sender], "only an approver can perform action");
        _;
    }

    receive() external payable {
        emit ReceiveCalled(msg.sender, msg.value);
    }

    function createToken(address _mintAddress , string memory _tokenURI, string memory _did, string memory _questID, bytes32 requestId, bytes32 r, bytes32 s, uint8 v) public returns(uint){
        //require(!checkNFTURI[_tokenURI], "this URI already is being used!");
        require(!didQuestCheck[_did][_questID], "this did already has NFT for quest");
        require(approvers[msg.sender] || msg.sender == _mintAddress , "sender not allowed to mint");
        uint256 _randomNumber = randomNumberContract.requestResults(requestId);
        require(signVerifyContract.metaDataVerify(_mintAddress, _randomNumber, _did, _questID, r, s, v), "incorrect minting signature");//put in all params and then mint
        
        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        
        _mint(_mintAddress, newItemId);
        _setTokenURI(newItemId, _tokenURI);
        setApprovalForAll(marketplace, true);
        didQuestCheck[_did][_questID] = true;
        emit NFTCommitMinted(_mintAddress, _tokenURI, _questID);
        return newItemId;
        
    }

    function addApprover(address _approver) public onlyOwner {
        require (!approvers[_approver], "address is already an approver");
        approvers[_approver]=true;
    }

    
        
    

    function createToken(string memory tokenURI) public returns (uint) {
        // this function needs access control!
        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();

        _mint(msg.sender, newItemId);
        _setTokenURI(newItemId, tokenURI);
        
        
    }
}
}